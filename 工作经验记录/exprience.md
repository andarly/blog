### 自动生成接口包给前端使用
作为一个前端开发来说，对接接口的时候，需要跟后端沟通url、参数、返回结构。这是一件烦躁、无趣、可优化的事情。假如根据后台代码可以生成一份可以直接给前端调用的类库，可以减少前端很多编程、沟通时间。另外生成的接口代码因为有版本控制，即使后台开发不经意修改过接口后，也会非常快的把修改过的接口暴露出来。基于当时的项目使用swagger做接口管理，swagger有个接口提供详细接口信息，结合freemarker，很容易将这想法实现了。  
后来深入了解到swagger官方也提供代码生成器，但原理是反过来的：先定义接口，然后基于流行框架，生成前后台接口，前台依赖接口代码写界面渲染，后台实现接口，写业务逻辑。这种机制也让我联想到之前接触过的ice框架（一个跨平台的rpc框架）。

### dlna做家居控制
很久以前，有个盒子软件叫歌吧，很好奇手机基于局域网跟盒子互相感知，互相发现的技术。反编译进一步研究，发现是用的dlna协议，而且使用了一个开源框架:cling。后来做智能家居，苦于没有规范的通信协议，自己定义的协议漏洞百出。想到手机控制盒子的场景，刚好我们的家居控制也是基于盒子+usb的实现，cling官方demo也是模拟一个灯泡开关。所以我决定使用它作为家居控制的通信框架，效果跟现在投屏控制类似。然而局限性也很明显，外网环境无法控制，没有推广。

### android项目模块化
当时的tv项目比较杂，包含物业管理、家居控制、购物商城、摄像监控等。开始的设计是每个模块一个app，app之间登录、推送等功能相同，而且有数据交互。一个人维护多个app，就已经非常艰难。如果遇到交互的bug需要同时更新多个app，简直就是噩梦。
经过多次代码重构，对功能的提炼，对项目做出模块化。传统的项目是金字塔结构，模块化的结果会类似一个棱形结构。顶部是一些类库，中间是业务模块，最下层是启动层。通过组合，可以生成多个app，比如登录+家居控制模块+启动层就可以是一个小的app。当所有模块都依赖后，就是一个完整的app。经过模块化之后的项目非常灵活，可以随意增减功能，另外可以通过屏蔽不必要的功能缩短开发编译。现在想想，这跟springboot的想法不谋而合，只是我的太直接了，依赖就启用，springboot隔了starter做配置。

### android项目插件化
插件化是对模块化的进一步提升。模块化使得功能组合复用，提高开发效率和体验。插件化可以快速、静默更新功能，优化了用户的体验。当时插件化框架比较多，个人比较喜欢small，比较灵活，有一套自己的gradle编译插件，无缝切换app和插件开发模式。但是经过初步实践，我认为基于small做插件化，旧项目改动会比较大，small会更适合全新项目的开发。我选择了另外一个插件化框架，它更适合我们项目的迁移。项目中只有界面部分做了插件化，后台服务考虑到改动少，而且避免插件化框架限制，依然使用原生的方式。界面和后台的交互统一通过eventbus框架。经过插件化，用户开始下载一个10m的app，只包含框架和基本功能，之后用到的模块功能都是后期下载、加载的，而且保持最新状态。

### 差量更新
曾经遇到一个需求，一个问卷功能，设计问卷、题目、选项三个表，依次为主从关系。在编辑的时候以问卷作为单位，编辑可能只改某个选项，或者改了涉及到更新或新增三个表的数据。按照需求，编辑完后需要做一键更新保存。通常遇到这个需求，同事设计用多个确认按钮，只进行对单个表进行单独操作，被需求无线吐槽。有的的开发可能会想着监听输入框，做ajax请求。这个方案可能会好点，但是确认按钮是多余的？焦点事件触发后用户真的希望提交？我设计了个更好的方案，灵感来自版本控制系统，代码做了修改之后，版本管理系统能对比出修改的代码，上传差分文件，服务器的版本系统根据差分文件和旧版本代码，生成新代码。基于这种思路，我找到了一个json对比工具。它对比出的差分数据使用jsonpath，action，value表示，某个节点做了增删改操作，结果是value。另外接口接受修改后的全json数据，包含修改的，对比计算在后段进行，避免客户端不支持该工具或者不同语言客户端对比算法差异。

#docker swarm服务依赖问题解决
#